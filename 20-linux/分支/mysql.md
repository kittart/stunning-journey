### 1.==Mysq 三大范式规则==:字段等于列，记录等于行
1. 第一范式(1NF):数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成包括整型、实数、字符型、逻辑型、日期型等。
**即:每个列都不可以再拆分;**
2. 第二范式(2NF):要求实体的属性完全依赖于主关键字。【主关键字:数据库表中有一个或者多个字段，这一个或多个字段的组能唯一标识一条记录，这一个或者多个字段组就成为主关键字(primary key)】主键优先数值类型
**即:在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。**
3. 第三范式(3NF):要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。要求数据表中的所有非主键字段不能依赖于其他非主键字段，非主键字段必须直接依赖于主键字段，不能间接依赖主键字段。(冗余)
**即:在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。**
- 对第二范式的理解:在第一范式的基础上，非主键列完全依赖于主键，**而不能是依赖于主键的一部分**    
**解读**:
	1. **函数依赖**: **如果通过A属性(属性组)，可以确定唯一B属性的值，那么B依赖于A**。比如上图的姓名，完全依赖于学号
	2. **完全函数依赖**: **如果A是一个属性组，则B属性值的确定需要依赖于A属性组中的所有的属性值**。属性组是指多个字段，那么比如我们要想知道一个分数，就必须依赖于学号和课程名称两个属性才能确定一个分数，其他的属性是不能确定某一个分数的
	3. **部分函数依赖**: **如果A是一个属性组，则B属性值的确定需要依赖A属性组的某一些字段即可**，例如学号和课程名称为一个属性组，那么学生姓名其实就只需要学号就可以确定
	4. **传递函数依赖**: **如果A属性(属性组),可以确定唯一个B属性的值，再通过B属性的值又可以唯一确定C属性的值**，例如一个学号确定一个系名，一个系名对应一个系主任
	5. **主键**:在一张表中，一个属性或者属性组，被其他所有属性完全依赖，则称这个属性为该码的表.
### 2.SQL语言:
**DDL【Data Definition Language】数据定义语言**:<mark style="background: #ADCCFFA6;">用来维护存储数据的结构</mark>。代表指令:create、drop(完全删除表、数据库)、alter(修改表结构，也可以删一列的名字)、truncate(删除表的数据，结构还在)。
**DML【Data Manipulation Language】数据操纵语言**:<mark style="background: #ADCCFFA6;">用来对数据进行操作</mark>。代表指令:insert，delete(后面跟where条件)全部删除保留表结构，update(只能修改某个数据)，DML中又单独分了一个 DQL数据查询语言，代表指令是 select。
**DCL【Data Control Language】数据控制语言**:<mark style="background: #ADCCFFA6;">用来管理数据库用户、控制数据库的访问权限，同时授权、撤销权限和事务控制等操作</mark>。代表指令:grant(赋权)，revoke(撤回权限)commit(提交，默认自动提交，提交前可uback返回)
<span style="background:rgba(240, 167, 216, 0.55)">注意:经常参与运算的列不能有空值存在;</span>
![[file-20240919171240565.png]]

### 3.mysql操作:
1. 查询：
	1. 使用函数:==其他函数+聚合函数==(分组汇总，形成汇总列):sum，maxmin，avg，【count(跟，`*`，列名(不计算nul格)，常数)】;==注意:如果selectsum(id)后不能再加普通列名==;as 给列起别名，聚合函数不可以，其他函数可以加列名:
	2. 子查询，嵌套查询，先运行子查询，取别名
	3. IS 运算符:  IS NULL 、 IS NOT NULLNULL值比较，用来判断字段的值是否为空值(NULL)is null是一个比较运算符，可以在任何使用运算符的地方使用它，例如select或where语句中。
	4. ![[file-20240917205900038.png]]


##### mysql基础操作:
属性名= =字段名
- **基础流程**: 
1. **连接数据库**: mysq! -u"用户名"-p"密码",h"lP".
2. **查看数据库**:Show database;
3. **打开数据库**: use数据库名;-------->查看里面的表 showtables select update insert delete.. 
4. **增删改**:
	1. create database数据库名;---->创建数据库
	2. create table数据表名(字段1名字段1类型[字段1约束],字段2名字段2类型[字段2约束]..);------->创建一个表，需要先进入一个数据库中
	3. insert into<font color="#c00000">表名(属性列名1,属性列名2..)</font>values(属性1值，属性2值，…),(属性1值，属性2值，….)---------==插入数据==，红色部分可以不需要，表示所有属性列都逐一插入;DML语言
	4. update表名set属性列名1=表达式1,属性列名2=表达式2..(where条件)
	-->例如:update student set ssext ='女where sname='张三';where()可省略
	-->==修改数据==，DML数据库操作语言
	5. delete from表名(where条件)----->例如:delete fromstudent where id='10086';------->==删除数据==，id那一个记录，DML
6、<font color="#c00000">**查询**</font>--->DML的DQL数据库查询语言;<font color="#c00000">单表查询</font>
(1、一张表--->select `*`from表名;
(2、查询多列(字段)------->select字段1,字段2,字段3....from表名:
(3)where条件查询------>select字段1,字段2,字段3 from表名where条件表达式;
1)=-->select`*`from student where class =1;2)in ---->select`*`from student where age in (18,20);注意:单行多列子查询:可以用“=”或者in;多行多列子查询:不能用“=”应该用in。
where后可以接:关系、逻辑、is运算符---->(<,=,!=,(not)between and;)、
(and、not、or、in、exists(比in块)、like、any、all、some).is null,is not null
3)like %任意字符， 单个字符，一个汉字一个字符哦!--->例如:select字段1,字段2...frome表名where字段(not)like'字符串%;
4)空值查询:is null ----->select name ,age from studentwhere age is null;
(4、去重查询:distinct ----->select distinct字段名from表名
(5、对查询结果进行排序:sort by asc升序，desc降序>select字段1,字段2...from表名order by属性名

6.1、查询--->多表查询book.id----》book表中的id字段(属性名，列名)
1、select`*`from t book,t bookType;----->编号相同的会在-起使用;
70
2、内连接查询(两张或以上的表连接起来查询需要的数据),查到的数据会横向连接起来 -------例如:select`*`frombook,booktype where book.bookType=bookType.id ;
3、外联查询(两张及以上的表连接起来查询某张表的信息)两个表会横向连接--------例如:select`*`from book,booktype where book.id=1or booktype.id=1;
4、左连接查询，横向连接，例如，book先放出来，表二连接表-，石不够用null加上，左为主----->select`*`from book leftjoin booktype on book.bookType=booktype.id;
5、右连接查询;右边为主表，所以左边不够会补nu;先写的先放出来
----->select`*`from book right join booktype onbook.bookType=booktype.id;
多条件连接查询where,join..on后面条件可以多个
(asc)desc];------>例如:select`*`from student order by age desc;//从大到小
(6、分组查询，一个组一个组的查找grop by --->group by属性名[having条件表达式][with rollup];1)单独使用无意义，与group_concat()函数一起:把同一组的放到一起;
------例如:select class,group concat(sname)from studentgroup by class;//统计每个 年级，生成一个列，列出各组人名;2)与聚合函数一起使用:(sum,max,min,avg,count)------->例如:select class,count(sname)from student groupby class;//统计每个年级人数
人
3)与having一起使用，(显示条件的输出结果);-->例如:select class,group concat(sname)fromstudent group by class having count(sname)>3; //班级大于3个人
4)与with rollup一起使用(最后加入一个总和行)-->例如:select class,group concat(sname)fromstudent group by class with rollup;(7、limit分页查询----->select字段1,字段2,..from表名limit显示开始的行号，记录个数;
--->例如:select`*`from student limit O,5; //显示前五条记录
mysql操作:
1、查询:
1、使用函数:聚合函数(分组汇总，形成汇总列):sum,max,min,avg,count(跟，*,列名(不计算nu 格),常数)注意:如果select sum(id)后不能再加普通列名;as给列起别名，聚合函数不可以，其他函数可以加列 名;:2、子查询，嵌套查询，先运行子查询，取别名;
![[138baa944fcea3cd4e4d06bfa3d7cb6.png]]

---



![[file-20240915090917376.png]]



#### 查询：
`select * from stu;`
`select id,name from stu;`
`select id,name from stu dual;` 伪列，每次只返回一行
###### 去重
distinct 
##### 聚合函数
sum() count()  avg()  max() min()
注意：
`count(*) 
`count(常数)` 
`count(列名)` 如果有null就不显示
### 重点
##### 1. 基本连接查询
> SELECT 表1.字段1, 表2.字段2, ... 
> FROM 表1 
> JOIN 表2 ON 表1.共同字段 = 表2.共同字段;`
##### 2. 连接多个表并查询特定信息
> SELECT 表1.字段1, 表2.字段2, 表3.字段3, ...<font color="#7030a0">//指定要从查询中返回</font><font color="#7030a0">的字段</font>
> FROM 表1 <font color="#7030a0">//指定查询的主表</font>
> JOIN 表2 ON 表1.共同字段 = 表2.共同字段 
> 	<font color="#7030a0">//用于将主表和其他表连接起来 `ON`: 定义连接条件</font>
> JOIN 表3 ON 表2.共同字段 = 表3.共同字段
> WHERE 条件; <font color="#7030a0">//用于过滤查询结果，只返回满足特定条件的记录</font>。
> ==查询的结果是联接表的结果集，所有符合条件的记录都会被返回。==
##### 3. 使用子查询筛选数据
> SELECT 表1.字段1, 表2.字段2, ...<font color="#7030a0">//选择要从查询中返回的字段</font>
> FROM 表1 //指定查询的主表
> JOIN 表2 ON 表1.共同字段 = 表2.共同字段<font color="#7030a0">//连接多个表，以将它们的数据合并在一起。</font>
> WHERE 表1.字段 = ( <font color="#7030a0">//用于过滤查询结果，返回符合条件的记录</font>
> SELECT 子查询字段
> FROM 子查询表
> WHERE 子查询条件
> );
> ==子查询可以返回单个值或一组值，主查询使用这些值来匹配==
##### 4. 聚合查询与分组
>SELECT 表1.字段, 聚合函数(表2.字段) AS 聚合结果 <font color="#7030a0">//你希望在结果集中显示的字段</font>
>FROM 表1 <font color="#7030a0">//指定查询的主表</font>
>JOIN 表2 ON 表1.共同字段 = 表2.共同字段 <font color="#7030a0">//将 表1 和 表2 通过 共同字段 连接起来。</font>
>GROUP BY 表1.字段;<font color="#7030a0">//根据 表1.字段 对结果进行分组。聚合函数将对每个分组的 表2.字段 进行计算</font>。
##### 5. 排序和限制查询结果
>SELECT 表1.字段1, 表2.字段2, ...
>FROM 表1
>JOIN 表2 ON 表1.共同字段 = 表2.共同字段
>ORDER BY 排序字段 DESC <font color="#7030a0">//用于对结果集进行'列'排序。`排序字段` 指定用于排序的字段，`DESC` 表示降序排列，`ASC`（默认）表示升序排列</font>
>LIMIT 限制数;<font color="#7030a0"> //限制查询结果的记录数。`限制数` 指定返回的记录数量。</font>
>![[file-20240919155358346.png]]

##### 6. case语句
>case when 条件1 then..
>when 条件2 then ..
>when 条件3 then ..
>else
>and



### **视图**
视图（View）是从一个或多个表（或视图）导出的表。视图与表（有时为与视图区别，也称表为基本表——Base Table）不同，视图是一个虚表，数据库中只存储视图的定义。对视图的数据进行操作时，系统根据视图的定义去操作与视图相关联的基本表。

>CREATE OR REPLACE VIEW VIEW_NAME 
 >AS SQL 查询语句 ;


### 流程控制-循环语句
**while循环**
特点：
- 先检查条件，只有条件为真时才执行循环体。
- 如果条件一开始就为假，则循环体不会执行。
>WHILE condition DO
>    -- 循环体
>    END WHILE;
![[file-20240921155143207.png]]


**loop循环**
特点：
- 不需要在循环头指定条件。
- 必须使用 `LEAVE` 语句退出循环，否则会进入死循环。
- 适合执行次数未知的循环，通过 `IF` 语句控制退出。
>label_name: LOOP
>    -- 循环体
 >   IF condition THEN
>        LEAVE label_name;
>    END IF;
>END LOOP;


**repeat循环**
特点：
- 至少执行一次循环体，因为条件在循环结束时才判断。
- 常用于需要先执行再检查条件的场景。
>REPEAT
>    -- 循环体
>UNTIL condition
>END REPEAT;


---
**防范SQL注入攻击**
1）参数化查询：使用参数化查询或预编译语句，确保用户输入被当作数据处理，而不是SQL代码
2）输入验证：对用户输入进行严格的验证和过滤，防止恶意代码的插入
3）最小权限原则：为数据库连接分配最小的必要权限，减少攻击者可能造成的破坏
4）错误处理：不要向用户显示详细的数据库错误信息，以防攻击者利用这些信息进行攻击
5）更新和维护：定期更新数据库和应用程序，及时修补已知的安全漏洞

  
---



## 练习
- T_Score表
![[file-20240918151439574.png|300]]
![[file-20240918153208217.png]]
![[file-20240918153328202.png]]

- [ ] 1、要求建立学生表、课程表、成绩表、教师表 学生有8个：
	![[file-20240918151954715.png]]
- [ ] 2、查询所有同学的学号、姓名、选课数、总成绩
	![[file-20240918173638797.png]]
	
- [ ] 3、查询“001”课程比“002”课程成绩高的所有学生的学号、分数
	![[file-20240918174733240.png]]
- [ ] 4、查询平均成绩大于60分的同学的学号和平均成绩
	![[file-20240918180233390.png]]
- [ ] 5、查询姓“李”的老师的个数
	![[file-20240918181741653.png]]
- [ ] 6、查询没学过“齐北”老师课的同学的学号、姓名
	![[file-20240918181108789.png]]
- [ ] 7、查询学过“齐北”老师所教的所有课的同学的学号、姓名
- [ ] 8、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名
- [ ] 9、查询每门课程被选修的学生数 
- [ ] 10、查询没有学全所有课的同学的学号、姓名
	![[file-20240919165041273.png]]
- [ ] 11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名
- [ ] 12、查询至少学过学号为“001”同学所有课的其他同学学号和姓名
- [ ] 13、把“成绩”表中“李来”老师教的课的成绩都更改为此课程的平均成绩
	![[file-20240920151651614.png]]
- [ ] 14、按平均成绩从高到低显示所有学生的“C++”、“C”、两门的课程成绩，按如下形式显示： 学生ID,C/C++,有效课程数,有效平均分
	![[file-20240920151514860.png]]
- [ ] 15、向成绩表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2号课的平均成绩
- [ ] 16、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分
- [ ] 17、查询出生年份在“2006”年以后出生的学生的姓名、性别、出生年份
	![[file-20240920151613553.png]]
- [ ] 18、查询各科成绩前三名的记录:(不考虑成绩并列情况)
- [ ] 19、统计各分数段人数显示结果如下:课程ID,课程名,<60人数,60<=x<80,>=80
	![[file-20240920151549494.png]]
- [ ] 20、查询如下课程成绩第 3 名到第 6 名的学生成绩单： 1号课程,2号课程,3号课程,4号课程 [学生ID],[学生姓名],1号课程,2号课程,3号课程,4号课程,平均成绩
- [ ] 21、查询不同老师所教不同课程平均分从高到低显示
- [ ] 22、编写触发器，如果成功删除一个同学，那么触发器删除该同学选课记录。
- [ ] 23、写存储过程，传入学生名等信息，自动在选课表里面选项所有课，并将成绩设置为0分
- [ ] 24、查询选修“李其”老师所授课程中，每门成绩最高的学生姓名及其成绩（假设每门课最高分只有一个人）	 按如下个格式输出    课程名称  学生姓名  成绩
- [ ] 25、查询每门功成绩最好的前两名









