详细点这个---==[[5.进线程间通信]]==
## 1.进程基本概念
- **进程控制块PCB**：操作系统使用进程控制块（PCB）来记录进程的所有信息。PCB 包含进程 ID（PID）、进程状态、寄存器内容、内存地址空间、打开的文件描述符、调度信息等
	- PID:进程唯一的标识符，是操作系统把PID放在进程的PCB中
- **进程**：运行中的程序就是进程（process）
- **进程ID**：系统会给每一个进程分配一个数字进行标记，称为进程ID（PID）
- **父进程**：每个进程都有一个父进程（创建它的进程），并可以创建一个或多个子进程
	在shell中输入命令运行，则shell就是父进程，运行的程序就是shell的子进程。（守护进程除外，守护进程的父进程是init[进程ID为1]）
## 2.查看进程状态==STAT==： 
>ps -ef **可以看见PPID**
>![[Pasted image 20240824101914.png|400]]
>ps -aux  **可以看见STAT**
>![[Pasted image 20240824102817.png|400]]
关于进程状态：
![[Pasted image 20240824103545.png|500]]

**进程退出的时候，它是==不会立即释放空间==的，它的PCB会保存一段时间让父进程或者操作系统读取，让父进程或操作系统知道这个进程即将退出了，然后父进程或者操作系统释放掉进程占用的资源和空间**。**一般情况下，清理进程资源空间的操作都是父进程**。
⭕️ **僵尸进程**：就是在进程退出的时候，**依然会在内存里面待一段时间**，这个时间就是专门让它的父进程来处理的，**如果父进程没有能力把这个进程完整地释放掉，造成这个进程地尸体一直在内存里面，那现在这个进程就是僵尸进程**
	- 造成僵尸进程的原因有**仨**：一个是操作系统不稳定，一个是代码写的烂，一个是操作习惯不好

⭕️ **孤儿进程**：当父进程衍生出多个子进程后，**父进程先没了**，**只留下了子进程**，**这些子进程就叫孤儿进程** 
	直接杀死父进程，孤儿进程的变化就是：PPID变化了，变成了 1
	- 再说一遍 PID： **PID是操作系统加载进程时，给进程占用的内存空间的一个标识符，这个标识符就是PID**  操作系统是计算机开机的时候加载的，所以操作系统的标识符是1，**就是说操作系统的 PID 为1**
	- 所以杀死父进程，导致了子进程变成孤儿进程，操作系统大善人，去领养了这个孤儿子进程，**孤儿进程的父进程是操作系统**，导致子进程的 PPID 变成1 --**如果这个子进程一直没人管，会一直占用内存空间，如果它不依赖任何进程存活，我们就无法控制它，会导致内存泄漏**


## 3.进程常用命令
###### **top** 动态实时查看进程的详细信息




## 4.进程管理
###### **kill** 指令
- kill PID 杀掉进程
- kill -9 [PID]   通过kill去杀掉进程
	-9 在这里是一个控制信号，意思是强制中断一个进程的执行，从内存中删除这个进程
	这个信号并不会被进程捕捉，就是意思一下
	![[Pasted image 20240824180226.png|250]]
某些进程的状态会有个+号，有无+号是为了区分前台后台，是给操作系统看的
- kill -l   小写l，查看所有的信号
注意：kill 是专门针对进程的 PID 的，每次使用记得用 ps 来查看要操作的进程的 PID


## 5.前台后台任务
 - 1.转后台运行 -时间长的会占用前台的
在命令后面加入==&==便可以直接使任务运行初直接在后台运行
> & - jobs - fg编号
> 最开始在后台执行 然后查看后台任务 然后转前台执行

 - 2.转后台暂停
在运行中输入==Ctrl+Z==会把当前任务转至后台**暂停**。此时使用==jobs==可以显示后台的任务，每个任务都有一个编号
**bg [ 后台任务编号 ]可以使任务在后台继续执行**
**fg [ 后台任务编号 ]把后台的任务转至前台执行**
> ctrl z - jobs - bg编号 - fg编号
> 运行暂停转后台，查看后台任务，后台继续执行（状态变成 &），转前台执行
- 任务结束需要在前台，才能ctrl c结束

**注意**：
- 如果转后台的东西会输出，一定要先重定向一下输出，不然还是会占用前台资源
- ==交互式任务，不能转后台==
**前台**：
举个例子，我们输入指令vim，此时会进入vim的操作平台，这时我们就处于前台状态。 而像我们在bash下执行我们的程序时，比如执行不断地打印，这些打印情况等我们都可以看到，这就是前台进程。就像Windows下的qq，此时我打开qq，并且处在它的界面上使用，此时qq就是一个前台进程。
**后台**：
​ 而后台就是指任务可以自动执行，不用我们人为干预，我们也无法使用ctrl c中止。

---


## 6.[[进程通信]]

## 7.进程优先级
ps -lA 查看进程优先级
寻找PRI关键字，下面的数字就是进程优先级，这个PRI值越低，据说明进程的优先级别越高，必须通过 **nice**值去调整，nice值就是PRI之后的NI
**新的 PRI = 进程默认PRI + nice 值，这个nice值有正有负**
调整优先级
`nice -n number PS` 还没运行的进程
`renice [number][PID]  number`是想要的nice值，PID就是你要操作的进程
>NI范围是-20~19。数值越大优先级越低（人越好，越不容易占有自己想要的，很讽刺对吧）
>普通用户调整NI值的范围是0~19，而且只能调整自己的进程。
>普通用户只能调高NI值，而不能降低。如原本NI值为0，则只能调整为大于0。
>只有root用户才能设定进程NI值为负值，而且可以调整任何用户的进程。

## 8.进程的四个重要概念
- **竞争性**：因为cpu资源优先，所以进程难免会存在竞争行为，具体体现在优先级上。
- **独立性**：进程运行期间，各个进程是不会相互干扰的，即使是父子进程。
- **并行**：**多个cpu同时处理多个进程的行为**叫做并行，虽然CPU只有1个，但是**CPU处理指令的速率是纳秒级**别的
- **并发**：在一段时间内，每个进程都可以被cpu处理一部分指令，这种行为称为并发。
关于并发：
**时间片**:每一次运行能被CPU处理多久
⭕️ 首先 CPU 处理进程**不是一次性被cpu处理完的**，是**分批次处理**的。假设有三个进程 ABC 都在运行队列之中，每个进程的**时间片**都是10毫秒，那么现在 CPU 处理进程 A 的时候，处理10毫秒，**不管进程A剩下多少命令没有被执行，都会直接把进程A放到运行队列最后**，然后去执行下一个指令，而这个切换进程的过程就叫**进程切换**
⭕️ 关于进程切换的时候： 每一个CPU都有一套寄存器，有一些关键寄存器
