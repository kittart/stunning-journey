

#### 1.匹配字符
格式：
>`.` 匹配任意单个字符，不能匹配换行
>`[]`匹配指定范围内的任意单个字符
>`[^]`表示取反
>`[0-9a-zA-Z]`匹配大写小写和数字
>`[:blank:]`空白字符（空格和制表符）
>`[:space:]` 水平和垂直的空白字符
>`[]`
>![[file-20240903210453192.png|400]]
>![[file-20240903210523422.png|400]]
#### 2.配置次数
格式：
> `*`匹配前面的字符任意次，包括0次，贪婪模式，尽可能长的匹配
> `.*` 匹配任意长度的任意字符，不包括0次
> `\?` 匹配前面的字符0或1次
> `\+` 匹配前面的字符至少1次
> `\{n\}` 匹配前面的字符至少n次
> `\{m,n\}` 匹配前面的字符至少m次，至多n次
> `\{,n\}` 匹配前面的字符至多n次
> `\{n,\}` 匹配前面的字符至少n次
> ![[file-20240903211434600.png|400]]
> ![[file-20240903211803831.png|400]]
#### 3.定位出现的位置
 > ^定位行首，用于模式最左侧
 > $定位行尾，用于模式最右侧
 > ^aaa$ 用于模式匹配整行 
 > 例子：`^[A-Za-z0-9]+@(126|163|99)\\.com$`
 > ^$ 空行
 > `^[[:space:]].*$` 空白行
 > `\<或\b`定位单词左侧
 > `\>或\b`定位单词右侧
 > `\<aaa\>`
 > ![[file-20240903212243087.png|400]]
 
#### 4.分组和向后引用
 格式
- 分组：`\(\)`将一个或多个字符捆绑在一起，当作一个整体进行处理，分组括号中的模式匹配内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：`\1,\2,\3`
- 后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身
	- `\1`表示从从左侧起，第一个左括号以及与之匹配右括号之间的模式所匹配到的字符
	- `\2`表示从左侧起，第2个左括号以及与之匹配右括号之间的模式匹配所匹配到的字符
	- `\&`表示前面的分组中的所有字符
	![[file-20240903212946834.png|400]]

```c
"^\d+$"　　//非负整数（正整数 + 0）   
"^[0-9]*[1-9][0-9]*$"　　//正整数   
"^((-\d+)|(0+))$"　　//非正整数（负整数 + 0）   
"^-[0-9]*[1-9][0-9]*$"　　//负整数   
"^-?\d+$"　　　　//整数   
"^\d+(\.\d+)?$"　　//非负浮点数（正浮点数 + 0）   
"^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数   
"^((-\d+(\.\d+)?)|(0+(\.0+)?))$"　　//非正浮点数（负浮点数 + 0）   
"^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点  
数   
"^(-?\d+)(\.\d+)?$"　　//浮点数   
"^[A-Za-z]+$"　　//由26个英文字母组成的字符串   
"^[A-Z]+$"　　//由26个英文字母的大写组成的字符串   
"^[a-z]+$"　　//由26个英文字母的小写组成的字符串   
"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串   
"^\w+$"　　//由数字、26个英文字母或者下划线组成的字符串   
"^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"　　　　//email地址   
"^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$"　　//url   
/^13\d{9}$/gi手机号正则表达式  
public static bool IsValidMobileNo(string MobileNo)  
  {  
   const string regPattern = @"^(130|131|132|133|134|135|136|137|138|139)\d{8}$";  
   return Regex.IsMatch(MobileNo, regPattern);  
  }  
正则表达式--验证手机号码:13[0-9]{9}  
实现手机号前带86或是+86的情况:^((\+86)|(86))?(13)\d{9}$  
电话号码与手机号码同时验证:(^(\d{3,4}-)?\d{7,8})$|(13[0-9]{9})   
提取信息中的网络链接:(h|H)(r|R)(e|E)(f|F)  *=  *('|")?(\w|\\|\/|\.)+('|"|  *|>)?    
提取信息中的邮件地址:\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*    
提取信息中的图片链接:(s|S)(r|R)(c|C)  *=  *('|")?(\w|\\|\/|\.)+('|"|  *|>)?  
提取信息中的IP地址:(\d+)\.(\d+)\.(\d+)\.(\d+)      
提取信息中的中国手机号码:(86)*0*13\d{9}      
提取信息中的中国固定电话号码:(\(\d{3,4}\)|\d{3,4}-|\s)?\d{8}      
提取信息中的中国电话号码（包括移动和固定电话）:(\(\d{3,4}\)|\d{3,4}-|\s)?\d{7,14}      
提取信息中的中国邮政编码:[1-9]{1}(\d+){5}      
提取信息中的中国身份证号码:\d{18}|\d{15}      
提取信息中的整数：\d+      
提取信息中的浮点数（即小数）：(-?\d*)\.?\d+      
提取信息中的任何数字  ：(-?\d*)(\.\d+)?    
提取信息中的中文字符串：[\u4e00-\u9fa5]*      
提取信息中的双字节字符串  (汉字)：[^\x00-\xff]*
```




## 三剑客
### grep

|      | 作用                     |     |
| ---- | ---------------------- | --- |
| grep | 检索返回，对行进行处理，返回字符串在的那一行 |     |
| auk  | 格式化输出，把行拆分成字段          |     |
| sed  | 对行进行处理，正则匹配            |     |

#### grep常用命令参数
-  -A<显示行数>：除了显示符合范本样式的那一列之外，并显示该行之后的内容。
-  -B<显示行数>：除了显示符合样式的那一行之外，并显示该行之前的内容。
-  -C<显示行数>：除了显示符合样式的那一行之外，并显示该行之前后的内容。
-  -c：统计匹配的行数
-  **-e ：实现多个选项间的逻辑or 关系**
-  **-E：扩展的正则表达式**
-  -f FILE：从FILE获取PATTERN匹配
-  -F ：相当于fgrep
-  -i --ignore-case 忽略字符大小写的差别
-  -n：显示匹配的行号
-  -o：仅显示匹配到的字符串
-  -q： 静默模式，不输出任何信息
-  -s：不显示错误信息。
-  **-v：显示不被pattern 匹配到的行，相当于[^] 反向匹配**
-  -w ：匹配 整个单词
#### 1. 基本字符匹配
- **`a`**: 匹配字符 "a"。
- **`.`（点号）**: 匹配除换行符以外的任意一个字符。例如，`g.d` 可以匹配 `god`、`gad` 或 `g_d` 等。
#### 2. 字符类（Character Classes）
- **`[abc]`**: 匹配方括号中的任意一个字符。`[abc]` 可以匹配 "a"、"b" 或 "c"。
- **`[^abc]`**: 匹配除 "a"、"b"、"c" 之外的任意字符。插入符号 `^` 放在方括号内表示取反。
- **`[a-z]`**: 匹配小写字母的任意一个，例如 "a" 到 "z"。
- **`[A-Z]`**: 匹配大写字母的任意一个，例如 "A" 到 "Z"。
- **`[0-9]`**: 匹配数字的任意一个，例如 "0" 到 "9"。
#### 3. 元字符（Metacharacters）
- **`\d`**: 匹配任意数字，等价于 `[0-9]`。
- **`\D`**: 匹配任何非数字字符，等价于 `[^0-9]`。
- **`\w`**: 匹配任意单词字符（字母、数字或下划线），等价于 `[a-zA-Z0-9_]`。
- **`\W`**: 匹配任何非单词字符，等价于 `[^a-zA-Z0-9_]`。
- **`\s`**: 匹配任何空白字符（空格、制表符、换行符等）。
- **`\S`**: 匹配任何非空白字符。
#### 4. 量词（Quantifiers）
- **`*`**: 匹配前面的字符零次或多次。例如，`bo*` 可以匹配 `b`、`bo`、`boo`、`booo` 等。
- **`+`**: 匹配前面的字符一次或多次。例如，`bo+` 可以匹配 `bo`、`boo`、`booo`，但不匹配 `b`。
- **`?`**: 匹配前面的字符零次或一次。例如，`bo?` 可以匹配 `b` 或 `bo`。
- **`{n}`**: 匹配前面的字符恰好 n 次。例如，`o{2}` 匹配 "oo"。
- **`{n,}`**: 匹配前面的字符至少 n 次。例如，`o{2,}` 匹配 "oo"、"ooo"、"oooo" 等。
- **`{n,m}`**: 匹配前面的字符至少 n 次，至多 m 次。例如，`o{2,4}` 匹配 "oo"、"ooo" 或 "oooo"。
#### 5. 边界匹配（Anchors）
- **`^`**: 匹配字符串的开始。例如，`^Hello` 匹配以 "Hello" 开头的字符串。
- **`$`**: 匹配字符串的结束。例如，`World$` 匹配以 "World" 结束的字符串。
- **`\b`**: 匹配一个单词边界。例如，`\bcat\b` 只匹配独立的 "cat"，而不匹配 "catch"。
- **`\B`**: 匹配非单词边界。例如，`\Bcat\B` 可以匹配 "category" 中的 "cat"。
#### 6. 分组和替代（Groups and Alternation）
- **`(abc)`**: 捕获组，匹配 "abc"，并捕获它以供以后使用。
- **`(a|b)`**: 匹配 "a" 或 "b"（逻辑或操作符）。
- **`(?:abc)`**: 非捕获组，匹配 "abc" 但不捕获它。
#### 7. 转义字符（Escape Characters）
- **`\`**: 用于转义字符。例如，如果你想匹配一个点号 `.` 而不是它作为元字符的功能，可以使用 `\.`
#### 例子讲解
- **`grep -E '^Hello' example.txt`**: 匹配所有以 "Hello" 开头的行。
- **`grep -E 'World$' example.txt`**: 匹配所有以 "World" 结尾的行。
- **`grep -E '\d+' example.txt`**: 匹配所有包含一个或多个数字的行。
- **`grep -E 'cat|dog' example.txt`**: 匹配包含 "cat" 或 "dog" 的行
# [[awk]]
### awk
>`awk` `[options]` `'program'` `var=value` `file``…`
>`awk` `[options] -f programfile var=value` `file``…`
>`awk` `[options]` `'BEGIN{ action;… } pattern{ action;… } END{ action;… }'` `file` `...`
#### 常用命令
- -F fs：fs指定输入分割符，fs可以是字符串或者正则表达式，
- -v var=value：赋值一个用户定义变量，将外部变量传递给awk
- -f scripile:从脚本中读取awk命令
#### awk的内置变量
格式
> FS：**输入字字段分隔符，默认为空白字符**
> OFS：**输出字段分隔符**，默认为空白字符
> RS：**输入记录分隔符**，指定输入时的换行符，原换行符仍有效
> ORS：**输出记录分隔符**，输出时用指定符号代替换行符
> **NF**：字段数量，**共有**多少字段， `$NF`引用最后一列，$(NF-1)引用倒数第2列
> **NR**：行号，后面可以跟多个文件，第二个文件行号继续从第一个文件最后行号开始
> **FNR**：各文件分别计数，行号，后跟一个文件和NR一样，跟多个文件，**第二个文件行号从1开始**
> FILENAME:当前文件名
> ARGC:**命令行参数的个数**
> ARGV：数组，保存的是命令行所给的各参数，**查看参数**
> ![[file-20240903215015542.png|400]]
```shell
`[root@along ~]``# awk '{print NR}' awkdemo awkdemo1`
`1`
`2`
`3`
`4`
`5`
`[root@along ~]``# awk END'{print NR}' awkdemo awkdemo1`
`5`
`[root@along ~]``# awk '{print FNR}' awkdemo awkdemo1`
`1`
`2`
`3`
`1`
`2`
`[root@along ~]``# awk '{print FILENAME}' awkdemo`
`awkdemo`
`awkdemo`
`awkdemo`
`[root@along ~]``# awk 'BEGIN {print ARGC}' awkdemo awkdemo1`
`3`
`[root@along ~]``# awk 'BEGIN {print ARGV[0]}' awkdemo awkdemo1`
`awk`
`[root@along ~]``# awk 'BEGIN {print ARGV[1]}' awkdemo awkdemo1`
`awkdemo`
`[root@along ~]``# awk 'BEGIN {print ARGV[2]}' awkdemo awkdemo1`
`awkdemo1`
```
